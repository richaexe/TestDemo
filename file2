import { Router } from "express";
import { EntityType, PrismaClient } from "@prisma/client";
import { populateDatabase } from "../scripts/populate";
import multer, { StorageEngine } from "multer";
import path from "path";
import fs from "fs";
import { Request, Response } from "express";
import { uploadDissemination } from "../controllers/admin/adminController";
import { validateDissemination } from "../validation/user/compliance/uploadDissemination";
import { addEntitySchema, deleteEntitySchema, deleteFileSchema, getEntitiesFilesSchema, uploadFileSchema } from "../validation/admin";
import logger from "../config/logger";
import requireUser from "../middleware/requireUser";

const prisma = new PrismaClient();

const adminRouter = Router();

const UPLOADS_DIR = "/var/www/uploads"; // New uploads path

// Ensure uploads directory exists
if (!fs.existsSync(UPLOADS_DIR)) {
  fs.mkdirSync(UPLOADS_DIR, { recursive: true });
}

adminRouter.post("/add-entity", async (req, res) => {
  let result = addEntitySchema.safeParse(req.body);
  if (!result.success) {
    res.status(400).json({
      error: true,
      message: result.error.errors[0].message
    });
    return;
  }
  logger.info("Adding Entity");
  const { name, type, year, previousData } = req.body;
  const parsedType = type?.toUpperCase();
  const parsedName = name?.toUpperCase();
  if (!name || typeof name !== "string") {
    res.status(400).json({ error: "Entity name is required." });
    return;
  }
  logger.info(`Adding Entity Bank ${req.body}`);
  if (!year || typeof year !== "number") {
    res.status(400).json({
      error: "Entity year not specified."
    });
    return;
  }

  if (!parsedType && !Object.values(EntityType).includes(parsedType as EntityType)) {
    res.status(400).json({
      error: "Entity type not specified."
    });
    return;
  }

  try {
    const existingEntity = await prisma.entity.findUnique({
      where: {
        name_type_year: {
          name: parsedName,
          type: parsedType as EntityType,
          year
        }
      }
    });

    if (existingEntity) {
      logger.error(`Error:An entity with the name "${name}" already exists in year "${year}" `);
      res.status(400).json({ error: `An entity with the name "${name}" already exists in year "${year}".` });
      return;
    }

    const newEntity = await prisma.entity.create({ data: { name: parsedName, type: type.toUpperCase(), year, previousRBIData: previousData, previousBCBSData: previousData } });
    if (!previousData) {
      try {
        const rbiJsonFilePath = "src/scripts/rbi_data.json";
        const bcbsJsonPath = "src/scripts/bcbs_data.json";
        await populateDatabase(newEntity.id, bcbsJsonPath, rbiJsonFilePath);

        res.status(201).json({ message: "Entity added and data populated successfully.", entity: newEntity });
      } catch (populateError) {
        await prisma.entity.delete({ where: { id: newEntity.id } });
        throw populateError;
      }
    } else {
      res.status(201).json({ message: "Entity added successfully.", entity: newEntity });
    }
  } catch (error: any) {
    console.error("Error adding entity:", error.message);
    res.status(500).json({ error: error.message || "Failed to add the entity." });
  }
});

adminRouter.delete("/delete-entity", async (req, res) => {
  let result = deleteEntitySchema.safeParse(req.body);
  if (!result.success) {
    res.status(400).json({
      error: true,
      message: result.error.errors[0].message
    });
    return;
  }
  const { id } = req.body;

  if (!id) {
    res.status(400).json({ success: false, message: "ID is required." });
    return;
  }

  try {
    // Check if the entity exists
    const entity = await prisma.entity.findUnique({
      where: { id: parseInt(id) },
    });

    if (!entity) {
      res.status(404).json({ success: false, message: "Entity not found." });
      return;
    }

    // Delete the entity
    await prisma.entity.delete({
      where: { id: parseInt(id) },
    });

    res.status(200).json({ success: true, message: "Entity deleted successfully." });
    return;
  } catch (error) {
    console.error("Error deleting entity:", error);
    res.status(500).json({ success: false, message: "Failed to delete entity." });
    return;
  }
});

const storage: StorageEngine = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, UPLOADS_DIR);
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = `${Date.now()}-${file.originalname}`;
    cb(null, uniqueSuffix);
  },
});

const upload = multer({
  storage,
  limits: { fileSize: 20 * 1024 * 1024 },
  fileFilter: (req, file, cb) => {
    const allowedMimeTypes = [
      "application/pdf",
      "application/vnd.ms-powerpoint",
      "application/vnd.openxmlformats-officedocument.presentationml.presentation",
    ];
    if (allowedMimeTypes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error("Invalid file type. Only PDF and PPT files are allowed."));
    }
  },
});


adminRouter.post("/upload-file", upload.single("file"), async (req: Request, res: Response) => {
  try {
    const { entityId } = req.query;
    if (!entityId) {
      if (req.file) deleteUploadedFile(path.join(UPLOADS_DIR, req.file.filename));
      return res.status(400).json({ error: "Entity ID is required." });
    }

    const entity = await prisma.entity.findUnique({ where: { id: Number(entityId) } });
    if (!entity) {
      if (req.file) deleteUploadedFile(path.join(UPLOADS_DIR, req.file.filename));
      return res.status(404).json({ error: "Entity not found." });
    }

    const existingFile = await prisma.file.findFirst({ where: { entityId: entity.id } });
    if (existingFile) {
      if (req.file) deleteUploadedFile(path.join(UPLOADS_DIR, req.file.filename));
      return res.status(400).json({ error: `Entity already has a file: "${existingFile.name}".` });
    }

    if (!req.file) return res.status(400).json({ error: "No file uploaded." });

    const { originalname, filename, mimetype, size } = req.file;
    const filePath = path.join(UPLOADS_DIR, filename);

    try {
      const file = await prisma.file.create({
        data: { name: originalname, path: filePath, mimeType: mimetype, size, entityId: entity.id },
      });

      return res.status(201).json({ message: "File uploaded successfully.", file });
    } catch (dbError) {
      console.error("Error saving file to database:", dbError);
      deleteUploadedFile(path.join(UPLOADS_DIR, filename));
      return res.status(500).json({ error: "Failed to save the file." });
    }
  } catch (error) {
    console.error("Error uploading file:", error);
    if (req.file) deleteUploadedFile(path.join(UPLOADS_DIR, req.file.filename));
    return res.status(500).json({ error: "Failed to upload the file." });
  }
});

adminRouter.get("/get-entities-files", async (req: Request, res: Response) => {
  const { entityId, page, pageSize } = req.query;
  const parsedPage = page ? Number(page) : 1;
  const parsedPageSize = pageSize ? Number(pageSize) : 10;

  if (isNaN(parsedPage) || parsedPage < 1 || isNaN(parsedPageSize) || parsedPageSize < 1) {
    return res.status(400).json({ error: "Invalid pagination parameters." });
  }

  try {
    if (entityId === "all") {
      const skip = (parsedPage - 1) * parsedPageSize;

      const entitiesWithFiles = await prisma.entity.findMany({
        skip,
        take: parsedPageSize,
        where: { files: { some: {} } },
        include: { files: true },
      });

      const totalEntities = await prisma.entity.count({ where: { files: { some: {} } } });

      return res.status(200).json({ entities: entitiesWithFiles, total: totalEntities, page: parsedPage, pageSize: parsedPageSize });
    } else if (entityId) {
      const entityWithFiles = await prisma.entity.findUnique({
        where: { id: Number(entityId) },
        include: { files: true },
      });

      if (!entityWithFiles) return res.status(404).json({ error: "Entity not found." });

      return res.status(200).json({ entities: [entityWithFiles] });
    } else {
      return res.status(400).json({ error: "Provide 'entityId' or use 'all'." });
    }
  } catch (error) {
    console.error("Error fetching entities and files:", error);
    return res.status(500).json({ error: "Failed to fetch files." });
  }
});

// Delete File Route
adminRouter.get("/delete-file", async (req: Request, res: Response) => {
  const { fileId } = req.query;
  if (!fileId) return res.status(400).json({ error: "File ID is required." });

  try {
    const file = await prisma.file.findUnique({ where: { id: Number(fileId) } });
    if (!file) return res.status(404).json({ error: "File not found." });

    const filePath = file.path; // Path is already saved with absolute location
    deleteUploadedFile(filePath);

    await prisma.file.delete({ where: { id: Number(fileId) } });

    return res.status(200).json({ message: "File deleted successfully." });
  } catch (error) {
    console.error("Error deleting file:", error);
    return res.status(500).json({ error: "Failed to delete file." });
  }
});

adminRouter.post("/uploadDissemination", requireUser('ADMIN'), upload.array("attachments"), validateDissemination, uploadDissemination);
// adminRouter.get("/getObligationsCirculars",  getObligationsCircularsAdmin);
// adminRouter.post("/uploadCircularObligationsByID", validateRequest(uploadObligationsSchema), uploadObligationsAdmin);

// adminRouter.get("/getTempSavedObligations",  getTempSaveObligations);
// adminRouter.post("/uploadTempObligations",validateRequest(uploadObligationsSchema), uploadTempSaveObligations);

// adminRouter.post("/uploadCertificate", uploadSelfCertification);
// adminRouter.get("/getSavedCertificates", getUploadedCertificates);

// adminRouter.get("/Lam/getUsersDetails", getUsersDetailsLamAdmin);
// adminRouter.patch("/Lam/updateUserDetails", updateUserDetailsLamAdmin);

export default adminRouter;
