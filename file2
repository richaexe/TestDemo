import { useEffect, useState, useRef } from "react";
import "../../../css/table.css";
import { apiFormRequest } from "../../axios/apiFormRequest";
import { apiRequest } from "../../axios/apiRequest";
import { removeBankFromEnd } from "../commonFunctions";
import ToastNotification from "../../../helpers/ToastNotification";

const ExcelTableBCBS = ({
    title,
    apiEndpoint,
    columnTitles,
    columnWidths,
    editableFields,
    dropdownOptions,
    remarksField,
}) => {
    const [data, setData] = useState([]);
    const [searchData, setSearchData] = useState("");
    const [entityList, setEntityList] = useState([]);
    const [selectedEntity, setSelectedEntity] = useState("");
    const [loading, setLoading] = useState(false);
    const [showRejected, setShowRejected] = useState(false);
    const [expandedRows, setExpandedRows] = useState([]);
    const [fetchBtnPressed, setFetchBtnPressed] = useState(false);
    const [showFilled, setShowFilled] = useState(false);
    const [notification, setNotification] = useState({ isOpen: false, type: '', message: '' });
    const [lastSaved, setLastSaved] = useState(null);

    // Use refs to keep track of unsaved changes
    const dataRef = useRef(data);
    const changedRowsRef = useRef({});
    const autosaveTimeoutRef = useRef(null);
    const autosaveIntervalRef = useRef(null);

    // Update ref when data changes
    useEffect(() => {
        dataRef.current = data;
    }, [data]);

    // Setup event listeners for page visibility and beforeunload
    useEffect(() => {
        // Save data when page becomes hidden (user switches tabs, minimizes window, etc.)
        const handleVisibilityChange = () => {
            if (document.visibilityState === 'hidden') {
                autoSaveChangedRows(false);
            }
        };

        // Save data before user leaves/refreshes the page
        const handleBeforeUnload = (e) => {
            if (Object.keys(changedRowsRef.current).length > 0) {
                autoSaveChangedRows(false);
                // Modern browsers require returnValue to be set
                e.preventDefault();
                e.returnValue = '';
                return '';
            }
        };

        // Set up autosave interval (every 1 minute)
        autosaveIntervalRef.current = setInterval(() => {
            if (Object.keys(changedRowsRef.current).length > 0) {
                autoSaveChangedRows(false);
            }
        }, 1 * 60 * 1000); // 1 minute in milliseconds

        document.addEventListener('visibilitychange', handleVisibilityChange);
        window.addEventListener('beforeunload', handleBeforeUnload);

        return () => {
            document.removeEventListener('visibilitychange', handleVisibilityChange);
            window.removeEventListener('beforeunload', handleBeforeUnload);
            clearInterval(autosaveIntervalRef.current);
            if (autosaveTimeoutRef.current) {
                clearTimeout(autosaveTimeoutRef.current);
            }
        };
    }, []);

    const toggleExpand = (id) => {
        setExpandedRows((prev) =>
            prev.includes(id) ? prev.filter((rowId) => rowId !== id) : [...prev, id]
        );
    };

    // mapping finalRiskScore to riskRating 
    const getRiskRating = (score) => {
        if (score >= 1 && score <= 9) return "LOW";
        if (score >= 10 && score <= 18) return "MEDIUM";
        if (score >= 19 && score <= 27) return "HIGH";
        if (score > 27) return "VERY_HIGH";
        return null;
    };

    const handleFieldChange = (id, field, value) => {
        // Track which rows have been changed
        changedRowsRef.current[id] = true;

        // Update the data state
        setData((prevData) =>
            prevData.map((row) =>
                row.id === id ? { ...row, [field]: value } : row
            )
        );

        // Set up debounced autosave (wait 3 seconds after last edit)
        if (autosaveTimeoutRef.current) {
            clearTimeout(autosaveTimeoutRef.current);
        }

        autosaveTimeoutRef.current = setTimeout(() => {
            autoSaveChangedRows(false);
        }, 3000); // 3 seconds debounce
    };

    // Function to autosave all changed rows
    // showToast parameter controls whether to show notifications
    const autoSaveChangedRows = async (showToast = true) => {
        const changedIds = Object.keys(changedRowsRef.current);

        if (changedIds.length === 0) return;

        let savedCount = 0;
        let errorCount = 0;

        for (const id of changedIds) {
            const rowToSave = dataRef.current.find(row => row.id === id);
            if (!rowToSave || rowToSave.isSubmitDisabled) continue;

            try {
                // Only auto-save with current status (don't submit)
                const currentStatus = rowToSave.status || 'NONE';
                const saveStatus = currentStatus === 'PENDING' ? 'PENDING' :
                    currentStatus === 'REJECTED' ? 'REJECTED' : 'NONE';

                await apiRequest("POST", `/api/user/${apiEndpoint}`, {
                    ...rowToSave,
                    status: saveStatus
                });

                savedCount++;
                delete changedRowsRef.current[id];
            } catch (error) {
                console.error(`Error auto-saving row ${id}:`, error);
                errorCount++;
            }
        }

        // Only show notification if explicitly requested (manual save button click)
        if (showToast && (savedCount > 0 || errorCount > 0)) {
            setNotification({
                isOpen: true,
                type: errorCount ? 'warning' : 'success',
                message: errorCount
                    ? `Auto-saved ${savedCount} items. Failed to save ${errorCount} items.`
                    : `Auto-saved ${savedCount} items successfully.`,
                id: Date.now()
            });
        }

        if (savedCount > 0) {
            setLastSaved(new Date());
        }
    };

    const getBreadcrumb = () => {
        let breadcrumb = ["Quality Assurance", "BCBS"];

        if (selectedEntity) {
            breadcrumb.push(selectedEntity.replace(/:/g, " "));
            if (showRejected) {
                breadcrumb.push("Rejected");
            } else if (showFilled) {
                breadcrumb.push("Filled");
            } else {
                breadcrumb.push("Unfilled");
            }
        }
        return breadcrumb
    };

    useEffect(() => {
        const fetchEntity = async () => {
            try {
                const response = await apiRequest("GET", "/api/user/entity");
                setEntityList(response.data.entity);
            } catch (error) {
                console.error("Error fetching entity:", error);
            }
        };

        fetchEntity();
    }, []);

    const fetchData = async (selectedEntity) => {
        if (selectedEntity === "") {
            setNotification({
                isOpen: true,
                type: 'warning',
                message: "Please Select an Entity First."
            });
            return;
        }
        setFetchBtnPressed(true)
        const selectedEntityDetails = selectedEntity.split(":");
        setLoading(true);
        try {
            const response = await apiFormRequest("GET", `/api/user/${apiEndpoint}`, { entityName: selectedEntityDetails[0], type: selectedEntityDetails[1], year: parseInt(selectedEntityDetails[2]) });
            const dataWithEditState = response.data.map((row) => ({
                ...row,
                isEditable: row.status !== "PENDING",
                isSubmitDisabled: row.status === "PENDING", // Disable if already submitted
            }));

            // Compute initial finalRiskScore and riskRating for all rows on load
            const computedData = dataWithEditState.map((row) => {
                const levelOfDocumentationScore = {
                    ADEQUATELY_DOCUMENTED: 1,
                    INADEQUATELY_DOCUMENTED: 2,
                    NOT_DOCUMENTED: 3,
                }[row.levelOfDocumentationOfControl] || 0;

                const levelOfAutomationScore = {
                    AUTOMATED: 1,
                    SEMI_AUTOMATED: 2,
                    MANUAL: 3,
                }[row.levelOfAutomationOfControl] || 0;

                const complianceScoreMap = {
                    NOT_APPLICABLE: 1,
                    FULLY_COMPLIED: 1,
                    PARTIALLY_COMPLIED: 2,
                    NOT_COMPLIED: 3,
                };
                const complianceScore = complianceScoreMap[row.complianceStatus] || 0;

                const finalRiskScore = (levelOfDocumentationScore * levelOfAutomationScore) * complianceScore;
                const riskRating = getRiskRating(finalRiskScore);

                return {
                    ...row,
                    srNo: row.srNo,
                    applicability: (row.applicability || "").toUpperCase().replace(" ", "_"),
                    overallControlDesignScore: levelOfDocumentationScore * levelOfAutomationScore || null,
                    complianceScore: complianceScore || null,
                    finalRiskScore,
                    riskRating,
                    isSubmitDisabled: false
                };
            });
            setData(computedData);
            // Clear changed rows tracking when fetching new data
            changedRowsRef.current = {};
        } catch (error) {
            console.error(`Error fetching ${title} data:`, error);
        } finally {
            setLoading(false);
        }
    };

    const saveChanges = async (id, status) => {
        const updatedRow = data.find((row) => row.id === id);
        // Temporarily hold any errors to show to the user
        const validationErrors = [];

        // Validate only for "PENDING" state
        if (status === "PENDING") {
            for (const field of editableFields) {
                const value = updatedRow[field];
                const strValue = String(value || "").trim();
                if (!strValue) {
                    validationErrors.push(`Please fill the mandatory field: ${field}.`);
                }
            }
        }

        // if validation fails, display the errors and stop submission
        if (validationErrors.length > 0) {
            setNotification({
                isOpen: true,
                type: 'warning',
                message: "Please fill all the fields before submitting."
            });
            return;
        }
        updatedRow.status = status;

        try {
            // Proceed with the submission if validation passes
            await apiRequest("POST", `/api/user/${apiEndpoint}`, updatedRow);

            // Update the row state after successful submission
            setData((prevData) =>
                prevData.map((row) => {
                    if (row.id === id) {
                        return {
                            ...row,
                            isEditable: status !== "PENDING",
                            isSubmitDisabled: status === "PENDING",
                        };
                    }
                    return row;
                })
            );

            // Remove from changed rows tracking after manual save
            delete changedRowsRef.current[id];

            setNotification({
                isOpen: true,
                type: 'success',
                message: `${status === "NONE" || status === "REJECTED" ? "Saved" : "Submitted"} successfully!`
            });

            setLastSaved(new Date());
        } catch (error) {
            console.error(`Error saving changes for ${title}:`, error);
            setNotification({
                isOpen: true,
                type: 'error',
                message: "Failed to Submit Changes. Please Try Again."
            });
        }
    };

    // Filter data based on search input
    const filteredData = data
        .filter((row) => {
            if (searchData) {
                const lowerCaseSearch = searchData.toLowerCase();
                return columnTitles.some((field) =>
                    String(row[field] || "").toLowerCase().includes(lowerCaseSearch)
                );
            }
            // Apply dropdown-based filters
            if (showRejected) return row.status === "REJECTED";
            if (showFilled) return row.status === "PENDING" || row.status === "APPROVED";
            return row.status === "NONE"; // Default to Unfilled
        })
        .sort((a, b) => (a.srNo || 0) - (b.srNo || 0));

    return (
        <div className="container"
            style={{
                maxWidth: "100%",
                transition: "width 0.3s, margin-left 0.3s",
            }}>
            <div className="breadcrumb">
                {getBreadcrumb().map((item, index) => (
                    <span key={index} className={`breadcrumb-item ${index === getBreadcrumb().length - 1 ? "active" : ""}`}>
                        {item}
                        {index !== getBreadcrumb().length - 1 && <span className="separator"> &gt; </span>}
                    </span>
                ))}
            </div>
            <div className="controls">
                <div className="left-layer-checker">
                    {/* select bank */}
                    <div className="control-group">
                        <div className="bank-select">
                            <label htmlFor="bankSelect" className="mr-2">Bank:</label>
                            <select
                                id="entitySelect"
                                value={selectedEntity}
                                onChange={(e) => {
                                    setFetchBtnPressed(false)
                                    setSelectedEntity(e.target.value);
                                    setData([]);
                                }}
                                className="select"
                                style={{ width: "200px" }}
                            >
                                <option value="">Select Bank</option>
                                {entityList.map((entityVal) => (
                                    <option key={entityVal.id} value={`${entityVal.name}:${entityVal.type}:${entityVal.year}`}>
                                        {`${removeBankFromEnd(entityVal.name)} ${entityVal.type} ${entityVal.year}`}
                                    </option>
                                ))}
                            </select>
                        </div>
                    </div>
                    {/* fetch data  */}
                    <button
                        onClick={() => {
                            fetchData(`${selectedEntity}`);

                        }}
                        className="fetch-button"
                        disabled={loading}
                    >
                        {loading ? "Loading..." : "Fetch Data"}
                    </button>
                    {/* input btn  */}
                    <input
                        type="text"
                        placeholder="Search here"
                        value={searchData}
                        onChange={(e) => setSearchData(e.target.value)}
                        className="search-input"
                    />
                </div>
                <div className="right-layer-checker">
                    <span className="mr-2">Filter by :</span>
                    <select
                        className="select"
                        style={{ width: "100px" }}
                        value={showRejected ? "REJECTED" : showFilled ? "APPROVED" : "NONE"} // default to none
                        onChange={(e) => {
                            const selectedValue = e.target.value;
                            setShowRejected(selectedValue === "REJECTED");
                            setShowFilled(selectedValue === "APPROVED");
                        }}
                    >
                        <option value="NONE">Unfilled</option>
                        <option value="APPROVED">Filled</option>
                        <option value="REJECTED">Rejected</option>
                    </select>
                </div>
            </div>

            {/* Last saved indicator */}
            {lastSaved && (
                <div className="last-saved-indicator" style={{ fontSize: '0.8rem', color: '#666', marginTop: '5px', textAlign: 'right' }}>
                    Last auto-saved: {lastSaved.toLocaleTimeString()}
                </div>
            )}

            {loading ? (
                <p>Loading...</p>
            ) : (
                <div className="table-container">
                    <table className="table">
                        <thead>
                            <tr>
                                {fetchBtnPressed && columnTitles
                                    .filter((title) => !(title === remarksField && !showRejected))
                                    .map((title) => (
                                        <th key={title} style={{ width: columnWidths[title] }}>
                                            {title
                                                .replace(/([A-Z])/g, " $1")
                                                .trim()
                                                .replace(/^./, (char) => char.toUpperCase())}
                                        </th>
                                    ))}
                                {!showFilled && fetchBtnPressed && (
                                    <>
                                        <th style={{ width: "100px" }}>Save</th>
                                        <th style={{ width: "100px" }}>Submit</th>
                                    </>
                                )}
                            </tr>
                        </thead>
                        <tbody>
                            {filteredData
                                .filter((row) => {
                                    if (showRejected) return row.status === "REJECTED";
                                    if (showFilled) return row.status === "APPROVED" || row.status === "PENDING";
                                    return row.status === "NONE";
                                })
                                .map((row) => (
                                    <tr key={row.id} className={changedRowsRef.current[row.id] ? "unsaved-changes" : ""}>
                                        {columnTitles
                                            .filter((field) => !(field === remarksField && !showRejected))
                                            .map((field) => (
                                                <td key={field} style={{ width: columnWidths[field] }}>
                                                    {editableFields.includes(field) && row.isEditable ? (
                                                        field === "applicability" ? (
                                                            <select
                                                                value={row[field] || ""}
                                                                onChange={(e) => handleFieldChange(row.id, field, e.target.value)}
                                                                className="select-editable"
                                                            >
                                                                <option value="">Select Applicability</option>
                                                                {dropdownOptions[field]?.map((option) => (
                                                                    <option key={option.value} value={option.value}>
                                                                        {option.label}
                                                                    </option>
                                                                ))}
                                                            </select>
                                                        ) : (
                                                            <textarea
                                                                value={row[field] || ""}
                                                                onChange={(e) => handleFieldChange(row.id, field, e.target.value)}
                                                                className="textarea-editable"
                                                                style={{
                                                                    resize: "vertical",
                                                                    minHeight: "80px",
                                                                    maxHeight: "150px",
                                                                }}
                                                            />
                                                        )
                                                    ) : field === "circularExtract" ? (
                                                        <div>
                                                            {expandedRows.includes(row.id)
                                                                ? row[field]
                                                                : `${row[field].slice(0, 150)}`}
                                                            {row[field].length > 100 && (
                                                                <button
                                                                    className="read-more-btn"
                                                                    onClick={() => toggleExpand(row.id)}
                                                                >
                                                                    {expandedRows.includes(row.id)
                                                                        ? "....Read Less"
                                                                        : "....Read More"}
                                                                </button>
                                                            )}
                                                        </div>
                                                    ) : (
                                                        row[field] || "-"
                                                    )}
                                                </td>
                                            ))}
                                        {/* Hide buttons for filled rows */}
                                        {!showFilled && (
                                            <>
                                                <td>
                                                    {row.isEditable && !row.isSubmitDisabled ? (
                                                        <button
                                                            onClick={() => saveChanges(row.id, showRejected ? "REJECTED" : "NONE")}
                                                            className="save-button"
                                                        >
                                                            Save
                                                        </button>
                                                    ) : (
                                                        <span className="no-action">No Actions</span>
                                                    )}
                                                </td>
                                                <td>
                                                    {row.isEditable ? (
                                                        <button
                                                            onClick={() => saveChanges(row.id, "PENDING")}
                                                            className="save-button"
                                                            disabled={row.isSubmitDisabled}
                                                        >
                                                            Submit
                                                        </button>
                                                    ) : (
                                                        <span className="no-action">No Actions</span>
                                                    )}
                                                </td>
                                            </>
                                        )}
                                    </tr>
                                ))}
                        </tbody>
                    </table>
                    {!filteredData.filter((row) =>
                        showRejected ? row.status === "REJECTED" : row.status !== "REJECTED"
                    ).length &&
                        !loading && (
                            <p className="px-4 py-4 text-center text-lg font-medium text-gray-700 bg-gray-100 rounded-lg shadow-md">
                                {showRejected ? "No rejected data available." : "No pending data available."}
                            </p>
                        )}
                </div>
            )}
            <ToastNotification
                isOpen={notification.isOpen}
                type={notification.type}
                message={notification.message}
                onClose={() => setNotification(prev => ({ ...prev, isOpen: false }))}
            />
        </div>
    );
};

export default ExcelTableBCBS;
