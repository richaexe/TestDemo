import axios from 'axios';
import Swal from 'sweetalert2';
import msalInstance, { loginRequest } from '../config/msalConfig';

const api = axios.create({
  baseURL: process.env.REACT_APP_BACKEND_URL,
  headers: {
    "Content-Type": "application/json"
  },
  withCredentials: true,
});

let isRefreshing = false;
let refreshSubscribers = [];
// const MAX_RETRY_COUNT = 1; // Set maximum retry attempts

const onRefreshed = (accessToken) => {
  refreshSubscribers.map((callback) => callback(accessToken));
};

const addRefreshSubscriber = (callback) => {
  refreshSubscribers.push(callback);
};

api.interceptors.response.use(
  response => response,
  async error => {
    const {
      config,
      response: { status }
    } = error;

    const originalRequest = config;
    if (status === 401 && !originalRequest._retry) {

      originalRequest._retry = true;
      originalRequest._retryCount = (originalRequest._retryCount || 0) + 1;

      if (!isRefreshing) {
        isRefreshing = true;

        try {
          const accounts = msalInstance.getAllAccounts();
          let newAccessToken;

          if (accounts.length > 0) {
            const response = await msalInstance.acquireTokenSilent({
              ...loginRequest,
              account: accounts[0],
            });
            const { accessToken } = response;

            const responseData = await axios.post(`${process.env.REACT_APP_BACKEND_URL}/api/auth/microsoft/refresh`, { token: accessToken }, { withCredentials: true });

            newAccessToken = response.accessToken;
          } else {
            const response = await axios.post(`${process.env.REACT_APP_BACKEND_URL}/api/auth/refresh-token`, {}, { withCredentials: true });
            newAccessToken = response.data.accessToken;
          }

          isRefreshing = false;
          onRefreshed(newAccessToken);
          refreshSubscribers = [];

          originalRequest.headers['Authorization'] = `Bearer ${newAccessToken}`;
          return api(originalRequest);
        } catch (tokenRefreshError) {
          isRefreshing = false;
          refreshSubscribers = [];
          Swal.fire({
            icon: 'error',
            title: 'Session expired. Please log in again.',
          }).then(() => {
            localStorage.clear();
            sessionStorage.clear();
            window.location.reload();
          });
          return Promise.reject(tokenRefreshError);
        }
      }

      return new Promise((resolve) => {
        addRefreshSubscriber((newAccessToken) => {
          originalRequest.headers['Authorization'] = `Bearer ${newAccessToken}`;
          resolve(api(originalRequest));
        });
      });
    }
    const errorMessage = error.response?.data || 'An error occurred';
    return Promise.reject(errorMessage);
  }
);

export const apiRequest = async (method, url, data = null) => {
  try {
    const response = await api({
      method,
      url,
      data,
    });
    return response;
  } catch (error) {
    throw error;
  }
};







...............................................................................
import React, { useState, useEffect, useRef } from 'react';
import { CheckCircle, AlertTriangle, XCircle, X } from 'lucide-react';

const ToastNotification = ({
  type = 'success',
  message,
  isOpen,
  onClose,
}) => {
  const [showDetails, setShowDetails] = useState(false);
  const [showIcon, setShowIcon] = useState(true);
  const detailsTimeoutRef = useRef(null);
  const iconTimeoutRef = useRef(null);
  const warningTimeoutRef = useRef(null);

  const typeConfig = {
    success: {
      bgColor: '#4f3d7f', // Theme purple
      hoverBgColor: '#5c4181', // Slightly lighter purple
      iconBgColor: 'rgba(255, 255, 255, 0.2)',
      icon: CheckCircle,
      label: 'Success',
      duration: 3000,
      borderColor: '#7e6bb4',
      detailsBg: '#f3f0ff', // Light purple background
      detailsText: '#4f3d7f', // Theme purple text
      accentColor: '#4f3d7f'
    },
    warning: {
      bgColor: '#f59e0b', // Amber
      hoverBgColor: '#d97706', // Darker amber
      iconBgColor: 'rgba(255, 255, 255, 0.2)',
      icon: AlertTriangle,
      label: 'Warning',
      duration: 5000,
      borderColor: '#fbbf24',
      detailsBg: '#fffbeb', // Light amber background
      detailsText: '#92400e', // Dark amber text
      accentColor: '#f59e0b'
    },
    error: {
      bgColor: '#ef4444', // Red
      hoverBgColor: '#dc2626', // Darker red
      iconBgColor: 'rgba(255, 255, 255, 0.2)',
      icon: XCircle,
      label: 'Error',
      duration: 5000,
      borderColor: '#f87171',
      detailsBg: '#fef2f2', // Light red background
      detailsText: '#b91c1c', // Dark red text
      accentColor: '#ef4444'
    }
  };

  const config = typeConfig[type] || typeConfig.success;

  const clearAllTimeouts = () => {
    if (detailsTimeoutRef.current) clearTimeout(detailsTimeoutRef.current);
    if (iconTimeoutRef.current) clearTimeout(iconTimeoutRef.current);
    if (warningTimeoutRef.current) clearTimeout(warningTimeoutRef.current);
  };

  useEffect(() => {
    if (isOpen) {
      // Reset state and clear timeouts on any change
      clearAllTimeouts();
      setShowIcon(true);
      setShowDetails(true);

      if (type === 'success') {
        detailsTimeoutRef.current = setTimeout(() => {
          setShowDetails(false);
          iconTimeoutRef.current = setTimeout(() => {
            setShowIcon(false);
            onClose();
          }, 3000);
        }, 5000);
      } else {
        detailsTimeoutRef.current = setTimeout(() => {
          setShowDetails(false);
        }, 5000);
        warningTimeoutRef.current = setTimeout(() => {
          setShowIcon(false);
          onClose();
        }, 10000);
      }
    } else {
      // Ensure reset when closed
      setShowDetails(false);
      setShowIcon(false);
    }

    return clearAllTimeouts;
  }, [isOpen, type, message, onClose]);

  const handleButtonClick = (e) => {
    e.preventDefault();
    e.stopPropagation();

    clearAllTimeouts();
    setShowDetails(true);

    detailsTimeoutRef.current = setTimeout(() => {
      setShowDetails(false);

      if (type === 'success') {
        iconTimeoutRef.current = setTimeout(() => {
          setShowIcon(false);
          onClose();
        }, 3000);
      }
    }, 5000);

    if (type !== 'success') {
      warningTimeoutRef.current = setTimeout(() => {
        setShowIcon(false);
        onClose();
      }, 10000);
    }
  };

  const handleClose = () => {
    clearAllTimeouts();
    setShowIcon(false);
    onClose();
  };

  if (!isOpen || !showIcon) return null;

  return (
    <div className="fixed bottom-8 right-8 flex flex-col items-end gap-3 z-50">
      <div className="flex flex-row gap-1">
        <div
          className="flex items-center rounded-lg shadow-lg transition-all"
          style={{
            background: config.bgColor,
            boxShadow: `0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05)`,
          }}
        >
          <button
            onClick={handleButtonClick}
            className="flex items-center justify-center text-white p-3 rounded-l-lg transition-colors"
            style={{
              background: config.iconBgColor,
            }}
          >
            <config.icon className="text-white w-5 h-5" />
          </button>
          {showDetails && (
            <>
              <span className="font-medium text-white px-3 py-2">{config.label}</span>
              <button
                onClick={handleClose}
                className="flex items-center justify-center px-3 py-2 text-white hover:text-white/80 transition-colors"
              >
                <X className="w-4 h-4" />
              </button>
            </>
          )}
        </div>
      </div>

      {showDetails && (
        <div
          className="rounded-lg shadow-lg overflow-hidden"
          style={{
            maxWidth: '350px',
            boxShadow: `0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05)`,
            animation: 'slideUpFade 0.3s ease-out forwards',
          }}
        >
          <div
            className="p-1"
            style={{
              background: `linear-gradient(to right, ${config.accentColor}, ${config.borderColor})`
            }}
          >
            <div
              className="p-4"
              style={{
                background: config.detailsBg,
                color: config.detailsText,
                borderRadius: '0.375rem'
              }}
            >
              <div className="flex items-start">
                <div className="mr-3">
                  <div
                    className="rounded-full p-2"
                    style={{
                      background: config.bgColor,
                    }}
                  >
                    <config.icon className="text-white w-4 h-4" />
                  </div>
                </div>
                <div className="flex-1">
                  <h4 className="text-sm font-medium mb-1" style={{ color: config.accentColor }}>
                    {config.label}
                  </h4>
                  <div className="text-sm">{message}</div>
                </div>
                <button
                  className="text-gray-400 hover:text-gray-600 transition-colors"
                  onClick={handleClose}
                >
                  <X className="w-4 h-4" />
                </button>
              </div>
            </div>
          </div>
        </div>
      )}

      <style>
        {`
          @keyframes slideUpFade {
            0% {
              transform: translateY(20px);
              opacity: 0;
            }
            100% {
              transform: translateY(0);
              opacity: 1;
            }
          }
        `}
      </style>
    </div>
  );
};

export default ToastNotification;



.............................................................................................


import React, { useState, useEffect } from "react";
import { apiRequest } from "../axios/apiRequest";
import { apiFormRequest } from "../axios/apiFormRequest";
import * as XLSX from "xlsx"
import { removeBankFromEnd } from "./commonFunctions";
import ToastNotification from "../../helpers/ToastNotification";

const formatDate = (dateString) => {
    if (!dateString) return "";
    const date = new Date(dateString);
    const day = String(date.getDate()).padStart(2, "0");
    const month = String(date.getMonth() + 1).padStart(2, "0");
    const year = date.getFullYear();
    return `${day}-${month}-${year}`;
};


const RepositoryPage = () => {
    const [selectedTable, setSelectedTable] = useState("");
    const [entities, setEntities] = useState([]);
    const [selectedEntity, setSelectedEntity] = useState("");
    const [data, setData] = useState([]);
    const [loading, setLoading] = useState(false);
    const [fetchBtn, setFetchBtn] = useState(false);
    const [expandedRows, setExpandedRows] = useState([]);
    const [uploadedData, setUploadedData] = useState([]);
    const [notification, setNotification] = useState({ isOpen: false, type: '', message: '' });


    const toggleExpand = (id) => {
        setExpandedRows((prev) =>
            prev.includes(id) ? prev.filter((rowId) => rowId !== id) : [...prev, id]
        );
    };

    const getBreadcrumb = () => {
        let breadcrumb = ["Quality Assurance", "Repository"];

        if (selectedEntity) {
            breadcrumb.push(selectedEntity.replace(/:/g, " "));
            if (selectedTable) {
                if (selectedTable === "rbi") {
                    breadcrumb.push("RBI");
                } else if (selectedTable === 'bcbs') {
                    breadcrumb.push("BCBS")
                }
            }
        }
        return breadcrumb
    };

    const tableOptions = [
        { id: "rbi", name: "RBI" },
        { id: "bcbs", name: "BCBS" },
    ];

    const dropdownOptions = {
        applicability: [
            { value: "APPLICABLE", label: "Applicable" },
            { value: "NOT_APPLICABLE", label: "Not Applicable" },
        ],
        theme: [
            { value: "PROCESS_AND_CONTROL", label: "Process and Control" },
            { value: "GOVERNANCE", label: "Governance" },
            { value: "PEOPLE", label: "People" },
            { value: "TECHNOLOGY", label: "Technology" },
        ],
        levelOfDocumentationOfControl: [
            { value: "ADEQUATELY_DOCUMENTED", label: "Adequately Documented" },
            { value: "INADEQUATELY_DOCUMENTED", label: "Inadequately Documented" },
            { value: "NOT_DOCUMENTED", label: "Not Documented" },
        ],
        levelOfAutomationOfControl: [
            { value: "AUTOMATED", label: "Automated" },
            { value: "SEMI_AUTOMATED", label: "Semi-Automated" },
            { value: "MANUAL", label: "Manual" },
        ],
        complianceStatus: [
            { value: "FULLY_COMPLIED", label: "Fully Complied" },
            { value: "PARTIALLY_COMPLIED", label: "Partially Complied" },
            { value: "NOT_COMPLIED", label: "Not Complied" },
            { value: "NOT_APPLICABLE", label: "Not Applicable" },
        ],
        riskRating: [
            { value: "VERY_HIGH", label: "Very High" },
            { value: "HIGH", label: "High" },
            { value: "MEDIUM", label: "Medium" },
            { value: "LOW", label: "Low" },
        ],
        mapStatus: [
            { value: "OPEN", label: "Open" },
            { value: "CLOSED", label: "Closed" },
        ],
        status: [
            { value: "APPROVED", label: "Approved" },
            { value: "REJECTED", label: "Rejected" },
        ],
    };

    const tableFields = {
        rbi: [
            "srNo",
            "circularReference",
            "regulator",
            "sectionReference",
            "applicability",
            "circularExtract",
            "policyReference",
            "policyExtract",
            "processCoverage",
            "keyControls",
            "observationReference",
            "theme",
            "levelOfDocumentationOfControl",
            "levelOfAutomationOfControl",
            "overallControlDesignScore",
            "complianceStatus",
            "complianceScore",
            "finalRiskScore",
            "riskRating",
            "managementResponses",
            "managementActionPlanTimelineDate",
            "mapAgeing",
            "mapStatus",
            "checkerRemarks",
        ],
        bcbs: [
            "srNo",
            "circularReference",
            "regulator",
            "sectionReference",
            "applicability",
            "circularExtract",
            "policyReference",
            "policyExtract",
            "processCoverage",
            "checkerRemarks",
        ],
    };

    const columnWidths = {
        srNo: "80px",
        circularReference: "200px",
        regulator: "100px",
        sectionReference: "160px",
        applicability: "160px",
        circularExtract: "400px",
        policyReference: "220px",
        policyExtract: "220px",
        processCoverage: "200px",
        keyControls: "200px",
        observationReference: "300px",
        theme: "200px",
        levelOfDocumentationOfControl: "200px",
        levelOfAutomationOfControl: "200px",
        overallControlDesignScore: "150px",
        complianceStatus: "200px",
        complianceScore: "150px",
        finalRiskScore: "150px",
        riskRating: "150px",
        managementResponses: "200px",
        managementActionPlanTimelineDate: "200px",
        mapAgeing: "150px",
        mapStatus: "150px",
        checkerRemarks: "200px",
    };

    useEffect(() => {
        fetchEntities();
    }, []);

    const fetchEntities = async () => {
        try {
            const response = await apiRequest("GET", "/api/user/entity");
            setEntities(response.data.entity || []);
        } catch (error) {
            console.error("Error fetching entities:", error);
        }
    };

    const fetchData = async () => {
        if (selectedEntity === "" || selectedTable === "") {
            //alert("Please select both a entity and a table.");
            setNotification({
                isOpen: true,
                type: 'warning',
                message: "Please Select Both an Entity and a Table."
            });
            setFetchBtn(false)
            return;
        }

        const selectedEntityDetails = selectedEntity.split(":");

        setLoading(true);
        try {
            const response = await apiFormRequest(
                "GET",
                `/api/user/${selectedTable}/repository`,
                { entityName: selectedEntityDetails[0], entityType: selectedEntityDetails[1], entityYear: selectedEntityDetails[2], previousRBIData: selectedEntityDetails[3], previousBCBSData: selectedEntityDetails[4] }
            );
            const sortedData = sortDataBySNo(response.data, "asc");
            setData(sortedData);
        } catch (error) {
            console.error(`Error fetching ${selectedTable} data:`, error);
        } finally {
            setLoading(false);
        }
    };

    const sortDataBySNo = (data, order) => {
        return [...data].sort((a, b) => {
            const sNoA = a.srNo || 0;
            const sNoB = b.srNo || 0;
            return order === "asc" ? sNoA - sNoB : sNoB - sNoA;
        });
    };

    const handleFileUpload = (event) => {

        setData([]);
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();

        reader.onload = (e) => {
            const data = new Uint8Array(e.target.result);
            const workbook = XLSX.read(data, { type: "array" });
            const sheetName = workbook.SheetNames[0];
            const sheet = workbook.Sheets[sheetName];
            let jsonData = XLSX.utils.sheet_to_json(sheet, { header: 1 });

            if (jsonData.length > 1) {
                const headers = jsonData[0].map((header) => header.toLowerCase());
                const body = jsonData.slice(1).map((row) => {
                    const rowObject = {};
                    row.forEach((cell, index) => {
                        rowObject[headers[index]] = cell;
                    });
                    return rowObject;
                });

                const invalidRows = body.filter(
                    (row) =>
                        row.regulator &&
                        row.regulator.toLowerCase() !== selectedTable.toLowerCase()
                );

                if (invalidRows.length > 0) {
                    setNotification({
                        isOpen: true,
                        type: "error",
                        message: `The 'regulator' field must match the selected table (${selectedTable}).`
                    });
                    setUploadedData([]);
                    setData([]);
                    return;
                }
                const mappedData = body.map((row) => {
                    const mappedRow = {};
                    tableFields[selectedTable]?.forEach((field) => {
                        const matchingKey = Object.keys(row).find(
                            (key) => key.toLowerCase() === field.toLowerCase()
                        );
                        if (matchingKey) {
                            let value = row[matchingKey];
                            if (typeof value === "string") {
                                if (field.toLowerCase() === "applicability") {
                                    value = value.trim().toUpperCase();
                                    value = value.trim().replace(/\s+/g, "_");
                                }
                            }
                            mappedRow[field] = value;
                        }
                    });
                    return mappedRow;
                });
                setUploadedData(mappedData);
                setData(mappedData);
            }
        };

        reader.readAsArrayBuffer(file);
    };


    const handleSave = async () => {

        if (!selectedTable || !selectedEntity) {
            //alert("Please select both a table and an entity.");
            setNotification({
                isOpen: true,
                type: 'warning',
                message: "Please Select Both an Entity and a Table."
            });
            return;
        }

        const entityUpload = entities.find(
            (entity) =>
                `${entity.name}:${entity.type}:${entity.year}` === selectedEntity
        );
        if (!entityUpload) {
            //alert("Selected Entity not found.");
            setNotification({
                isOpen: true,
                type: 'error',
                message: "Selected Entity not Found."
            });
            return;
        }
        const entityID = entityUpload.id;

        if (!uploadedData || uploadedData.length === 0) {
            //alert("Uploaded data is empty or invalid.");
            setNotification({
                isOpen: true,
                type: 'warning',
                message: "Uploaded Data is Empty or Invalid"
            });
            return;
        }

        if (selectedTable === 'rbi') {

            const modifiedData = uploadedData.map((item) => {
                return {
                    rbiCommonSrNo: item.srNo,
                    rbiCommonCircularReference: item.circularReference,
                    applicability: item.applicability ? item.applicability.toUpperCase() : null,
                    policyReference: item.policyReference ? item.policyReference : null,
                    policyExtract: item.policyExtract ? item.policyExtract : null,
                    processCoverage: item.processCoverage ? item.processCoverage : null,
                    keyControls: item.keyControls ? item.keyControls : null,
                    observationReference: item.observationReference ? item.observationReference : null,
                    checkerRemarks: item.checkerRemarks ? item.checkerRemarks.toUpperCase() : null,
                    status: "APPROVED",
                    theme: item.theme ? item.theme.toUpperCase() : null,
                    levelOfDocumentationOfControl: item.levelOfDocumentationOfControl ? item.levelOfDocumentationOfControl.toUpperCase() : null,
                    levelOfAutomationOfControl: item.levelOfAutomationOfControl ? item.levelOfAutomationOfControl.toUpperCase() : null,
                    overallControlDesignScore: item.overallControlDesignScore || null,
                    complianceStatus: item.complianceStatus ? item.complianceStatus.toUpperCase() : null,
                    complianceScore: item.complianceScore || null,
                    finalRiskScore: item.finalRiskScore || null,
                    riskRating: item.riskRating ? item.riskRating.toUpperCase() : null,
                    managementResponses: item.managementResponses ? item.managementResponses.toUpperCase() : null,
                    managementActionPlanTimelineDate: item.managementActionPlanTimelineDate
                        ? new Date(item.managementActionPlanTimelineDate)
                        : null,
                    mapAgeing: item.mapAgeing || null,
                    mapStatus: "CLOSED"
                };
            });

            try {
                const response = await apiRequest(
                    "POST",
                    `/api/user/${selectedTable}/upload-excel?entityId=${entityID}`,
                    {
                        data: modifiedData,
                    }
                );

                if (response?.status === 201 || response?.status === 200) {
                    //alert("Data saved successfully.");
                    setNotification({
                        isOpen: true,
                        type: 'success',
                        message: "Data Saved Successfully."
                    });
                    setUploadedData([]);
                    fetchEntities();
                } else {
                    //alert(`Unexpected response: ${response.status}. Please try again.`);
                    setNotification({
                        isOpen: true,
                        type: 'error',
                        message: `Unexpected response: ${response.status}. Please try again.`
                    });
                }
            } catch (error) {
                console.error("Error saving data:", error);

                if (error.response && error.response.data) {
                    //alert(`Failed to save data: ${error.response.data.error}`);
                    setNotification({
                        isOpen: true,
                        type: 'error',
                        message: `Failed to save data: ${error.response.data.error}`
                    });
                } else {
                    //alert("An unexpected error occurred. Please try again.");
                    setNotification({
                        isOpen: true,
                        type: 'error',
                        message: "An unexpected error occurred. Please try again."
                    });
                }
            }
        }

        else if (selectedTable === 'bcbs') {

            const modifiedData = uploadedData.map((item) => {
                return {
                    bcbsCommonSrNo: item.srNo,
                    bcbsCommonCircularReference: item.circularReference,
                    applicability: item.applicability ? item.applicability.toUpperCase() : null,
                    policyReference: item.policyReference ? item.policyReference : null,
                    policyExtract: item.policyExtract ? item.policyExtract : null,
                    processCoverage: item.processCoverage ? item.processCoverage : null,
                    checkerRemarks: item.checkerRemarks ? item.checkerRemarks : null,
                    status: "APPROVED",
                };
            });

            try {
                const response = await apiRequest(
                    "POST",
                    `/api/user/${selectedTable}/upload-excel?entityId=${entityID}`,
                    {
                        data: modifiedData,
                    }
                );

                if (response?.status === 201 || response?.status === 200) {
                    //alert("Data saved successfully.");
                    setNotification({
                        isOpen: true,
                        type: 'success',
                        message: "Data Saved Successfully."
                    });
                    setUploadedData([]);
                    fetchEntities();
                } else {
                    //alert(`Unexpected response: ${response.status}. Please try again.`);
                    setNotification({
                        isOpen: true,
                        type: 'error',
                        message: `Unexpected response: ${response.status}. Please try again.`
                    });
                }
            } catch (error) {
                console.error("Error saving data:", error);

                if (error.response && error.response.data) {
                    //alert(`Failed to save data: ${error.response.data.error}`);
                    setNotification({
                        isOpen: true,
                        type: 'error',
                        message: `Failed to save data: ${error.response.data.error}`
                    });
                } else {
                    //alert("An unexpected error occurred. Please try again.");
                    setNotification({
                        isOpen: true,
                        type: 'error',
                        message: "An unexpected error occurred. Please try again."
                    });
                }
            }
        }
    };

    const handleClearData = () => {
        setUploadedData([]);
        setData([]);
        document.getElementById("fileUpload").value = "";
    };

    return (
        <div className="container"
            style={{
                maxWidth: "100%",
                transition: "width 0.3s, margin-left 0.3s",
            }}>
            <div className="breadcrumb">
                {getBreadcrumb().map((item, index) => (
                    <span key={index} className={`breadcrumb-item ${index === getBreadcrumb().length - 1 ? "active" : ""}`}>
                        {item}
                        {index !== getBreadcrumb().length - 1 && <span className="separator"> &gt; </span>}
                    </span>
                ))}
            </div>
            <div className="controls_repo">
                <div className="control-group">
                    <label htmlFor="entitySelect" className="mr-2">
                        Select Entity:
                    </label>
                    <select
                        id="entitySelect"
                        value={selectedEntity}
                        onChange={(e) => {
                            setFetchBtn(false)
                            setSelectedEntity(e.target.value);
                            setData([]);
                            setUploadedData([]);
                            setExpandedRows([]);
                        }}
                        className="select"
                    >
                        <option value="">-- Select Entity --</option>
                        {entities.map((entity) => (
                            <option key={entity.name} value={`${entity.name}:${entity.type}:${entity.year}`}>
                                {`${removeBankFromEnd(entity.name)} ${entity.type} ${entity.year}`}
                            </option>
                        ))}
                    </select>
                </div>
                <div className="control-group">
                    <label htmlFor="tableSelect" className="mr-2">
                        Select Table:
                    </label>
                    <select
                        id="tableSelect"
                        value={selectedTable}
                        onChange={(e) => {
                            setFetchBtn(false)
                            setSelectedTable(e.target.value);
                            setData([]);
                            setUploadedData([]);
                            setExpandedRows([]);
                        }}
                        className="select"
                    >
                        <option value="">-- Select Table --</option>
                        {tableOptions.map((table) => (
                            <option key={table.id} value={table.id}>
                                {table.name}
                            </option>
                        ))}
                    </select>
                </div>
                <button
                    onClick={() => {
                        setFetchBtn(true)
                        fetchData()
                    }}
                    className="fetch-button"
                    disabled={loading}
                >
                    {loading ? "Loading..." : "Fetch Data"}
                </button>

                {entities.find(
                    (entity) =>
                        `${entity.name}:${entity.type}:${entity.year}` === selectedEntity
                )?.[selectedTable === 'rbi' ? 'previousRBIData' : selectedTable === 'bcbs' ? 'previousBCBSData' : null]
                    && selectedEntity
                    && selectedTable && (
                        <div className="upload-section flex items-center gap-4 p-4">
                            <label
                                htmlFor="fileUpload"
                                className="text-sm font-medium text-gray-700"
                            >
                                Upload Excel:
                            </label>
                            <div className="relative">
                                <input
                                    type="file"
                                    id="fileUpload"
                                    onChange={handleFileUpload}
                                    accept=".xlsx, .xls"
                                    className="absolute inset-0 w-full h-full opacity-0 cursor-pointer"
                                />
                                <button
                                    type="button"
                                    className="px-4 py-2 cursor-pointer bg-purple-900 text-white font-medium rounded-md shadow  focus:outline-none focus:ring-2  focus:ring-offset-2"
                                >
                                    Choose File
                                </button>
                            </div>
                        </div>
                    )}
                {uploadedData.length > 0 && (
                    <div className="button-container flex gap-4">
                        <button
                            className="px-4 py-2 cursor-pointer bg-red-600 text-white font-medium rounded-md shadow  focus:outline-none focus:ring-2  focus:ring-offset-2"
                            onClick={handleClearData}
                        >
                            Clear Data
                        </button>
                        <button className="px-4 py-2 cursor-pointer bg-purple-900 text-white font-medium rounded-md shadow  focus:outline-none focus:ring-2  focus:ring-offset-2" onClick={handleSave}>
                            Save Data
                        </button>
                    </div>
                )}
            </div>

            {loading ? (
                <p>Loading...</p>
            ) : (
                <div className="table-container">
                    <table className="table">
                        <thead>
                            <tr>
                                {(fetchBtn || data.length > 0) && tableFields[selectedTable]?.map((field) => (
                                    <th
                                        key={field}
                                        style={{
                                            width: columnWidths[field] || "auto",
                                        }}
                                    >
                                        {field.replace(/([A-Z])/g, " $1").trim().replace(/^./, (char) => char.toUpperCase())}
                                    </th>
                                ))}
                            </tr>
                        </thead>
                        <tbody>
                            {data.map((row) => (
                                <tr key={row.id}>
                                    {tableFields[selectedTable]?.map((field) => (
                                        <td
                                            key={field}
                                            style={{
                                                width: columnWidths[field] || "auto",
                                            }}
                                        >
                                            {field === "circularExtract" || field === "policyReference" || field === "policyExtract" || field === "processCoverage" || field === "keyControls" ? (
                                                <div>
                                                    {row[field] ? (
                                                        <>
                                                            {expandedRows.includes(row.id)
                                                                ? row[field]
                                                                : row[field].slice(0, 100)}
                                                            {row[field].length > 100 && (
                                                                <button
                                                                    className="read-more-btn"
                                                                    onClick={() => toggleExpand(row.id)}
                                                                >
                                                                    {expandedRows.includes(row.id) ? "....Read Less" : "....Read More"}
                                                                </button>
                                                            )}
                                                        </>
                                                    ) : (
                                                        <span>-</span>
                                                    )}
                                                </div>
                                            ) : dropdownOptions[field] ? (
                                                dropdownOptions[field].find(option => option.value === row[field])?.label || "-"
                                            ) : field === "managementActionPlanTimelineDate" ? (
                                                formatDate(row[field]) || "-"
                                            ) : (
                                                row[field] || "-"
                                            )}
                                        </td>
                                    ))}
                                </tr>
                            ))}
                        </tbody>
                    </table>
                    {!data.length && !loading && (
                        <p className="px-4 py-4 text-center text-lg font-medium text-gray-700 bg-gray-100 rounded-lg shadow-md">
                            No data available.</p>
                    )}
                </div>
            )}
            <ToastNotification
                isOpen={notification.isOpen}
                type={notification.type}
                message={notification.message}
                onClose={() => setNotification(prev => ({ ...prev, isOpen: false }))}
            />
        </div>
    );
};

export default RepositoryPage;

