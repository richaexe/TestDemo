import React, { useEffect, useState, useCallback, useMemo, memo } from "react";
import { useNavigate, useLocation } from "react-router-dom";
import Pagination from "../pagination/pagination";
import "../../css/pagination.css";
import "../../css/home.css";
import axios from "axios";
import { apiRequest } from "../axios/apiRequest";
import AnimatedHeader from "./animatedNotification";
import LoadingOverlay from "../loading/loader";
import ToastNotification from "../../helpers/ToastNotification";

// ** @@Refer [work item: 302] on azure board for visual represenation of home page implementation **

// child memo 
const CircularRow = memo(({ circular, showToast }) => {
  const navigate = useNavigate();
  const location = useLocation();
  const [isExpanded, setIsExpanded] = useState(false);
  // useCallback (bcz : call it when the circular changes not on every re-render)
  const handleShowFile = useCallback(async () => {
    try {
      const response = await axios.get(
        `${process.env.REACT_APP_BACKEND_URL}/api/user/circular/attachment/${circular.attachment}`,
        { responseType: "blob" }
      );
      const fileBlob = new Blob([response.data], {
        type: response.headers["content-type"],
      });
      const fileURL = URL.createObjectURL(fileBlob);
      window.open(fileURL, "_blank");
    } catch (error) {
      showToast("Error loading file", "error");
    }
  }, [circular.attachment, showToast]);

  const handleNavigation = useCallback(() => {
    navigate("/Dissemination", {
      state: {
        circular: circular,
        previousPath: location.pathname,
      },
    });
  }, [circular, location.pathname, navigate]);

  const toggleReadMore = () => {
    setIsExpanded(!isExpanded);
  };

  return (
    <tr>
      <td>{circular.Circular.id}</td>
      <td>{circular.Circular.circularReference}</td>
      <td>{circular.Circular.circularTitle}</td>
      <td>
        {isExpanded
          ? circular.applicability
          : `${circular.applicability.substring(0, 80)}...`}
        <button
          className="read-more-button"
          onClick={toggleReadMore}
        >
          {isExpanded ? "Read Less" : "Read More"}
        </button>
      </td>

      <td>
        {new Date(circular.Circular.circularDate).toLocaleDateString(
          "en-GB",
          {
            day: "2-digit",
            month: "2-digit",
            year: "numeric",
          }
        )}
      </td>
      <td>
        <button className="home-fetch-button" onClick={handleShowFile}>
          Show
        </button>
      </td>
      <td>
        <button className="home-fetch-button" onClick={handleNavigation}>
          Show
        </button>
      </td>
    </tr>
  );
});

// parent memo 
const CircularsTable = memo(({ title, circulars, pagination, onPageChange, isLoading, showToast }) => {
  if (!circulars || circulars.length === 0) return null;

  const { currentPage, totalPages } = pagination;

  //caLculated visible pages using the same logic as usePagination hook
  const pageDisplayLimit = 5;
  const startPage = Math.max(1, Math.min(
    currentPage - Math.floor(pageDisplayLimit / 2),
    totalPages - pageDisplayLimit + 1
  ));

  const visiblePages = Array.from(
    { length: Math.min(pageDisplayLimit, totalPages - startPage + 1) },
    (_, i) => startPage + i
  );

  return (
    <div className="">
      <h2 className="section-title" style={{ fontWeight: "bold" }}>
        {title} {isLoading && <LoadingOverlay />}
      </h2>
      <div className="home-page-table-container">
        <table className="home-page-table">
          <thead>
            <tr>
              <th>S.No.</th>
              <th>Reference Number</th>
              <th>Subject</th>
              <th>Applicability</th>
              <th>Date of Issue</th>
              <th>Show Circular</th>
              <th>Show Dissemination</th>
            </tr>
          </thead>
          <tbody>
            {circulars.map((circular, index) => (
              <CircularRow
                key={`${circular.id}-${index}`}
                circular={circular}
                showToast={showToast}
              />
            ))}
          </tbody>
        </table>
      </div>
      <Pagination
        currentPage={currentPage}
        totalPages={totalPages}
        paginate={onPageChange}
        nextPages={() => onPageChange(Math.min(currentPage + 1, totalPages))}
        prevPages={() => onPageChange(Math.max(currentPage - 1, 1))}
        visiblePages={visiblePages}
        startPage={startPage}
      />
    </div>
  );
});

const Home = () => {
  const location = useLocation();
  const [circularsData, setCircularsData] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [regulators, setRegulators] = useState([]);
  const [paginationState, setPaginationState] = useState({});

  // Toast notification state
  const [toastState, setToastState] = useState({
    isOpen: false,
    message: '',
    type: 'success'
  });

  // for loading the state of a particular regulator
  const [loadingRegulator, setLoadingRegulator] = useState(null);

  // Function to show toast notifications
  const showToast = useCallback((message, type = 'success') => {
    setToastState({
      isOpen: true,
      message,
      type
    });
  }, []);

  // Function to close toast notification
  const closeToast = useCallback(() => {
    setToastState(prev => ({
      ...prev,
      isOpen: false
    }));
  }, []);

  const formatRegulatorTitle = useCallback((regulator) => {
    return regulator
      .split("-")
      .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join(" ");
  }, []);

  // only re-render when path changes : [/home , /home/rejected] ) and 
  // this fetchData btn tracks pagination seperately for different regulators
  const fetchData = useCallback(async (regulatorToUpdate = null, page = 1, pageSize = 5) => {
    if (regulatorToUpdate) {
      setLoadingRegulator(regulatorToUpdate);
    } else {
      setLoading(true);
    }
    try {
      setLoading(regulatorToUpdate ? false : true);
      const isRejectedRoute = location.pathname === "/home/rejected";

      let url = `${process.env.REACT_APP_BACKEND_URL}/api/user/home-data`;

      const queryParams = [];

      if (isRejectedRoute) {
        queryParams.push('type=rejected');
      }

      queryParams.push(`page=${page}`);
      queryParams.push(`pageSize=${pageSize}`);

      // pushing the regulator that needs to be updated
      if (regulatorToUpdate) {
        queryParams.push(`regulator=${regulatorToUpdate}`);
      }

      //ADDDIng query parameters to URL
      if (queryParams.length > 0) {
        url += `?${queryParams.join('&')}`;
      }

      const response = await apiRequest("Get", url);

      if (response.data.success) {
        const { regulators: regulatorData, circulars: circularData, pagination } = response.data.data;

        // handling init case : load all regulators
        if (!regulatorToUpdate) {
          const regulatorsList = regulatorData.map(reg => reg.value);
          setRegulators(regulatorsList);
          setCircularsData(circularData);
        } else {
          setCircularsData(prevCircularsData => {
            // removing exisging circULAR that is not 
            const filteredData = prevCircularsData.filter(
              // we doing this bcz we only want to remove the regulator that needs to be updated (regulatorToUpdate)
              // ex: regular to update is RBI , remove only the regulator with rbi.. 
              circular => circular.Circular.regulator.toUpperCase() !== regulatorToUpdate.toUpperCase()
            );

            // merginG with not-removed (filteredData) and circularData (fetched from backend)  
            return [...filteredData, ...circularData];
          });
        }

        setPaginationState(prevPagination => ({
          ...prevPagination,
          ...(pagination || {})
        }));
      }

    } catch (error) {
      console.error('Error fetching data:', error);
      setError("Failed to fetch data.");
      showToast("Failed to fetch data", "error");
    } finally {
      setLoadingRegulator(null);
      setLoading(false);
    }
  }, [location.pathname, showToast]);

  useEffect(() => {
    fetchData();
  }, [fetchData]);

  // circularMap returns object [key : value pair]
  const circularsMap = useMemo(() => {
    if (!circularsData.length || !regulators.length) return {};

    const newCircularsMap = regulators.reduce((acc, regulator) => {
      const filteredCirculars = circularsData.filter(
        (circular) =>
          circular.Circular.regulator.toUpperCase() === regulator.toUpperCase()
      );
      if (filteredCirculars.length > 0) {
        acc[regulator] = filteredCirculars;
      }
      return acc;
    }, {});

    return newCircularsMap;
  }, [circularsData, regulators]);

  if (loading) {
    return <LoadingOverlay />;
  }

  if (error) {
    return <div className="error-container">{error}</div>;
  }

  const handlePageChange = (regulator, page) => {
    fetchData(regulator, page);
  };

  return (
    <div
      className="container mx-auto px-4 py-6"
      style={{
        maxWidth: "100%",
        transition: "width 0.3s, margin-left 0.3s",
      }}
    >
      <AnimatedHeader showRejected={location.pathname === "/home/rejected"} />

      <div className="space-y-8">
        {Object.entries(circularsMap).map(([regulator, circulars]) => (
          <CircularsTable
            key={regulator}
            title={formatRegulatorTitle(regulator)}
            circulars={circulars}
            pagination={paginationState[regulator] || { currentPage: 1, totalPages: 1 }}
            onPageChange={(page) => handlePageChange(regulator, page)}
            isLoading={loadingRegulator === regulator}
            showToast={showToast}
          />
        ))}
        {Object.keys(circularsMap).length === 0 && (
          <div className="text-center py-12 bg-gray-50 rounded-lg">
            <h3 className="text-xl text-gray-600">
              No circulars available.
            </h3>
          </div>
        )}
      </div>

      {/* Toast Notification Component */}
      <ToastNotification
        type={toastState.type}
        message={toastState.message}
        isOpen={toastState.isOpen}
        onClose={closeToast}
      />
    </div>
  );
};

export default Home;
